# vim:set sw=2 ts=2 et:
# This is a sample .gitlab-ci.yml created by wagtail-kit.  You should review
# it for any necessary changes.

# Stages are groups that jobs can be groupped into.
# Jobs within each stage run in parallel and if one of them fails, the next
# stage won't be run.
# This will set up the following:
#
# - Build stage: build of static assets.
# - Test stage: code style, migration, basic configuration checks and unit
#   tests.
# - Deploy stage: deploy to Heroku.
stages:
  - build
  - test
  - deploy

# Test if static assets can be built succesfully.
static:
  image: node:16
  stage: build
  script:
    # Make sure your project has a package-lock.json lockfile, otherwise this install will fail.
    - npm ci
    - npm run build:prod
  # Saving the job result as an artifact means that the files can be used by
  # other jobs.
  artifacts:
    name: 'static-$CI_JOB_ID'
    paths:
      - ./node_modules
      - ./rca/static_compiled
    expire_in: 1 week

poetry:
  # If you update the python image version here, make sure you update all jobs that depend on this
  # and the version in the Dockerfile and provision scripts as well
  image: python:3.8
  stage: build
  variables:
    POETRY_VERSION: 1.1.15
  script:
    - pip install poetry==$POETRY_VERSION
    - python -m venv venv
    - source venv/bin/activate
    - poetry install
  artifacts:
    name: 'poetry-$CI_JOB_ID'
    paths:
      - ./venv/
    expire_in: 30 mins

# Check python code style.
flake8:
  # Make sure the python image version here matches the poetry job
  image: python:3.8
  stage: test
  dependencies:
    - poetry
  before_script:
    - source venv/bin/activate
  script:
    - flake8 rca

# Check imports sort order, i.e. check whether they are in an alphabetical
# order and grouped properly.
isort:
  # Make sure the python image version here matches the poetry job
  image: python:3.8
  stage: test
  dependencies:
    - poetry
  before_script:
    - source venv/bin/activate
  script:
    - isort --check-only --diff rca fabfile.py

lint_js:
  image: node:16
  stage: test
  dependencies:
    - static
  script:
    - npm run lint:js

lint_css:
  image: node:16
  stage: test
  dependencies:
    - static
  script:
    - npm run lint:css

lint_format:
  image: node:16
  stage: test
  dependencies:
    - static
  script:
    - npm run lint:format

black:
  # Make sure the python image version here matches the poetry job
  image: python:3.8
  stage: test
  dependencies:
    - poetry
  before_script:
    - source venv/bin/activate
  script:
    - black --check ./

# Check settings, migrations and run tests.
test_python:
  # Make sure this Python version matches the version in your Dockerfile.
  image: python:3.8
  stage: test
  services:
    # Make sure this matches the Postgres version you run on your servers.
    - postgres:12.10
  dependencies:
    - static
    - poetry
  variables:
    POSTGRES_HOST_AUTH_METHOD: trust
    # Run tests with the production settings.
    DJANGO_SETTINGS_MODULE: rca.settings.production

    # SECRET_KEY is required by Django to start.
    SECRET_KEY: fake_secret_key_to_run_tests

    # Silence RECAPTCHA
    RECAPTCHA_PUBLIC_KEY: 'dummy-key-value'
    RECAPTCHA_PRIVATE_KEY: 'dummy-key-value'

    # This is the URL used by databases on our CI.
    DATABASE_URL: postgres://postgres@postgres/postgres

    # Don't redirect to HTTPS in tests.
    SECURE_SSL_REDIRECT: 'false'
  before_script:
    - source venv/bin/activate
  script:
    # We need to run the collectstatic command, because we use ManifestStaticFilesStorage.
    # Otherwise the check command will fail
    - python manage.py collectstatic --verbosity 0 --noinput --clear

    # Run system checks
    - python manage.py check

    # Check for missing migrations
    - python manage.py makemigrations --check --noinput

    # Create cache table.
    - python manage.py createcachetable

    # Run back-end tests
    - python manage.py test

test_js:
  image: node:16
  stage: test
  dependencies:
    - static
  script:
    # Run front-end tests
    - npm run test:coverage

.heroku_deploy_job_template: &heroku_deploy_job_definition
  before_script:
    # Install cURL and GnuPG to install Heroku CLI.
    # Install Git to push the code to Heroku. It uses HTTP to push the code.
    - apt-get update -y
    - apt-get install -y curl git gnupg

    # Install Heroku CLI.
    - curl https://cli-assets.heroku.com/install-ubuntu.sh | sh

    # Use Heroku credentials that you can add in your project settings on
    # GitLab. They can be obtained from sysadmin or pwman.
    - |
      cat >~/.netrc <<EOF
      machine api.heroku.com
        login $HEROKU_EMAIL
        password $HEROKU_TOKEN
      machine git.heroku.com
        login $HEROKU_EMAIL
        password $HEROKU_TOKEN
      EOF
    - chmod 600 ~/.netrc

    # Add Heroku's Git remote using Heroku CLI.
    - heroku git:remote --app $HEROKU_APP --remote heroku
  script:
    # Push to Heroku's Git via HTTP. Heroku always expects you to push to
    # master.
    - git push heroku HEAD:master

# Deploy to the staging server.
deploy_staging:
  # We use Debian image because Heroku has a lot of dependencies and is well
  # supported on Debian based distributions.
  image: debian:stretch
  stage: deploy
  variables:
    # Your app's name.
    #   $ heroku apps - t torchbox
    HEROKU_APP: rca-staging
  only:
    - staging
  <<: *heroku_deploy_job_definition

# Deploy to the production site.
deploy_production:
  # We use Debian image because Heroku has a lot of dependencies and is well
  # supported on Debian based distributions.
  image: debian:stretch
  stage: deploy
  variables:
    # Your app's name.
    #   $ heroku apps - t torchbox
    HEROKU_APP: rca-production
  only:
    - master
  when: manual
  before_script:
    # Install cURL and GnuPG to install Heroku CLI.
    # Install Git to push the code to Heroku. It uses HTTP to push the code.
    - apt-get update -y
    - apt-get install -y curl git gnupg

    # Install Heroku CLI.
    - curl https://cli-assets.heroku.com/install-ubuntu.sh | sh

    # Use Heroku credentials that you can add in your project settings on
    # GitLab. They can be obtained from sysadmin or pwman.
    - |
      cat >~/.netrc <<EOF
      machine api.heroku.com
        login $HEROKU_EMAIL
        password $HEROKU_TOKEN
      machine git.heroku.com
        login $HEROKU_EMAIL
        password $HEROKU_TOKEN
      EOF
    - chmod 600 ~/.netrc

    # Add Heroku's Git remote using Heroku CLI.
    - heroku git:remote --app $HEROKU_APP --remote heroku-production
  script:
    # Push to Heroku's Git via HTTP. Heroku always expects you to push to
    # master.
    - git push heroku-production HEAD:master

docs:
  image: python:3.8
  stage: deploy
  only:
    - master
  dependencies:
    - poetry
  before_script:
    - . .venv/bin/activate
  script:
    - mkdocs build
    - pushd site
    - tar -cvzf docs.tar.gz *
    - popd
    - mv site/docs.tar.gz .
  artifacts:
    paths:
      - docs.tar.gz
    expire_in: 1 week
